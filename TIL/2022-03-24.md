### JPA(Java Persistence API)
- 자바 ORM 기술에 대한 API 표준
	- **ORM**(Object Relational Mapping): 객체와 관계형 데이터베이스를 매핑해주는 것
- 장점
	1. 특정 데이터베이스에 종속되지 않아 데이터베이스를 얼마든지 변경 가능
	2. 객체지향적 프로그래밍: 직관적인 비즈니스 로직
	3. 생산성 향상: SQL문을 직접 작성하지 않고 객체를 사용하여 동작하기 때문에 효율적인 유지보수, 재사용성 증가
- 단점
	1. 복잡한 쿼리 처리
	2. 성능 저하 위험: 객체 간 매핑 설계 주의

### 엔티티
- 데이터베이스의 테이블에 대응하는 클래스
- 데이터베이스에 테이블 생성 -> java 클래스 생성 후 `@Entity` 어노테이션 붙이기

### 엔티티 매니저 팩토리
- 엔티티 매니저 인스턴스를 관리
- 애플리케이션 실행 시 한 개만 만들어지며 요청에 따라 엔티티 매니저를 생성

### 엔티티 매니저
- 영속성 컨텍스트에 접근하여 엔티티에 대한 데이터베이스 작업 제공
- 메소드: `find()`, `persist()`, `remove()`, `flush()` 등

### 엔티티 생명주기
|생명주기|내용|
|:--|:--|
|비영속(new)|`new` 키워드를 통해 생성된 상태로, 영속성 컨텍스트와 관련이 없음|
|영속(managed)|엔티티가 영속성 컨텍스트에 저장된 상태로, 데이터베이스에 저장되지 않고 트랜잭션 커밋 시점에서 반영됨|
|준영속 상태(detached)|영속성 컨텍스트에 엔티티가 저장되었다가 분리된 상태|
|삭제 상태(removed)|영속성 컨텍스트와 데이터베이스에서 삭제된 상태|

### 영속성 컨텍스트(Persistence Context)
- 엔티티를 영구 저장하는 환경
- **1차 캐시**
	- Map<KEY, VALUE>로 저장
	- `entityManager.find()` 호출 시 영속성 컨텍스트의 1차 캐시 조회
	- 엔티티가 존재할 경우 해당 엔티티 반환, 없을 경우 데이터베이스 조회 후 1차 캐시에 저장 및 반환
	- 하나의 트랜잭션에서 같은 키값으로 영속성 컨텍스트에 저장된 엔티티 조회 시 같은 엔티티 조회 보장
- **쓰기 지연 SQL 저장소**
	- `entityManager.persist()` 호출 시 1차 캐시에 저장 + 쓰기 지연 SQL 저장소에 SQL문 저장
	- 트랜잭션 커밋 시점에 저장된 SQL문들이 flush되면서 데이터베이스에 반영됨
	- 1차 캐시에 저장된 엔티티의 스냅샷 비교 후 변경 내용이 있다면 UPDATE SQL문을 쓰기 지연 SQL 저장소에 저장 (따로 UPDATE문 호출 불필요)